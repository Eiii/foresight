#include "foresight/experimentactiontype.h"

#include "foresight/experimentaction.h"
#include "foresight/domain.h"
#include "foresight/gp.h"
#include "foresight/statefactory.h"

#include <cassert>
#include <iostream>

using std::make_unique;

namespace fore {

//TODO: Add model info
ExperimentActionType::ExperimentActionType(
  ActionType::Id id, std::string name, Duration duration, bool cancelable,
  Resource::Amount requires, 
  Resource::Amount produces, 
  Resource::Amount upkeep,
  Model::Id model_id
) :
    ActionType(id, name, duration, cancelable, requires, produces, upkeep),
    model_id_(model_id) {}
    
std::vector<Action::Ptr> ExperimentActionType::GenerateActions(
  const State& state, const Domain& domain
) const
{
  //Generate 'base' action
  //NOTE: Assumes only one action will be generated by the base
  //class.
  auto base_actions(ActionType::GenerateActions(state, domain));
  assert(base_actions.size() == 1);
  const auto& base_action(base_actions[0]);

  //TODO: Calculate best input point on model
  const auto& model(domain.model(model_id_));
  auto gp(GP::GetGP(model, state));
  auto best_point(gp->CalculateBestPoint());
  double false_result(gp->CalculateMean(best_point));

  //TODO: Build/return resultant action 
  std::vector<Action::Ptr> final_actions;
  auto final_action(
      make_unique<ExperimentAction>(*base_action, best_point, false_result)
  );
  final_actions.emplace_back(std::move(final_action));

  return final_actions;
}

State ExperimentActionType::Start(
  const Action& action, const Domain& domain, const State& state
) const
{
  auto base_state(ActionType::Start(action, domain, state));
  StateFactory fact(base_state);

  const auto& exp_action(static_cast<const ExperimentAction&>(action));
  auto input_point(exp_action.input_point());
  auto false_result(exp_action.false_result());
  fact.AddFalseObservation(model_id_, input_point, false_result);

  return fact.Finish();
}

void ExperimentActionType::End(
  const Action& action, const Domain& domain, const State& state,
  StateFactory* fact
) const
{
  ActionType::End(action, domain, state, fact);

  const auto& exp_action(static_cast<const ExperimentAction&>(action));
  auto input_point(exp_action.input_point());
  fact->RemoveFalseObservation(model_id_, input_point,
                               exp_action.false_result());

  const auto& model(domain.model(model_id_));
  auto gp(GP::GetGP(model, state));
  auto real_result(gp->SimulatedResponse(input_point));
  fact->AddObservation(model_id_, input_point, real_result);
}

State ExperimentActionType::Cancel(const Action& target, 
                                   const State& state) const
{
  return ActionType::Cancel(target, state);
}

}
