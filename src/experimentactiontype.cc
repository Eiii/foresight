#include "foresight/experimentactiontype.h"

#include "foresight/domain.h"
#include "foresight/gp.h"
#include "foresight/statefactory.h"

#include <cassert>
#include <iostream>

namespace fore {

//TODO: Add model info
ExperimentActionType::ExperimentActionType(
  ActionType::Id id, std::string name, Duration duration, bool cancelable,
  Resource::Amount requires, 
  Resource::Amount produces, 
  Resource::Amount upkeep,
  Model::Id model_id
) :
    ActionType(id, name, duration, cancelable, requires, produces, upkeep),
    model_id_(model_id) {}
    
std::vector<Action::Ptr> ExperimentActionType::GenerateActions(
  const State& state, const Domain& domain
) const
{
  //Generate 'base' action
  //NOTE: Assumes only one action will be generated by the base
  //class.
  auto base_actions(ActionType::GenerateActions(state, domain));
  assert(base_actions.size() == 1);
  const auto& base_action(base_actions[0]);

  //TODO: Calculate best input point on model
  const auto& model(domain.model(model_id_));
  auto gp(GP::GetGP(model, state));
  auto best_point = gp.CalculateBestPoint();

  //TODO: Build/return resultant action 
  std::vector<Action::Ptr> final_actions;
  final_actions.emplace_back(base_action->Clone());

  return final_actions;
}

State ExperimentActionType::Start(const Action& action, 
                                  const State& state) const
{
  auto base_state(ActionType::Start(action, state));
  //TODO: Make a base
  StateFactory fact(base_state);

  //TODO: Get point from action
  Point input_point;
  return fact.Finish();
}

void ExperimentActionType::End(const Action& action, StateFactory* fact) const
{
  //TODO: 'base' End
  //TODO: Remove false observation
  //TODO: Calculate+add model observation
  ActionType::End(action, fact);
}

State ExperimentActionType::Cancel(const Action& target, 
                                   const State& state) const
{
  return ActionType::Cancel(target, state);
}

}
